# def print_board(board):
#     for row in board:
#         print(row)

# def is_valid(board, row, col, num):
#     # Check if the number is already present in the row
#     if num in board[row]:
#         return False
    
#     # Check if the number is already present in the column
#     if num in [board[i][col] for i in range(4)]:
#         return False
    
#     # Check if the number violates the cage sum constraint
#     cage_sum = 0
#     for i in range(row//2*2, row//2*2+2):
#         for j in range(col//2*2, col//2*2+2):
#             cage_sum += board[i][j]
#     if cage_sum + num > 10:
#         return False
    
#     return True

# def solve(board):
#     for row in range(4):
#         for col in range(4):
#             if board[row][col] == 0:
#                 for num in range(1, 5):
#                     if is_valid(board, row, col, num):
#                         board[row][col] = num
#                         if solve(board):
#                             return True
#                         board[row][col] = 0
#                 return False
#     return True

# # Example Killer Sudoku board (4x4)
# killer_sudoku_board = [
#     [0, 0, 2, 0],
#     [0, 0, 0, 0],
#     [0, 0, 0, 0],
#     [0, 0, 0, 0]
# ]

# if solve(killer_sudoku_board):
#     print("Solution found:")
#     print_board(killer_sudoku_board)
# else:
#     print("No solution exists.")

import random

def generate_board():
    return [[0 for _ in range(4)] for _ in range(4)]

def print_board(board):
    for row in board:
        print(row)

def is_valid_move(board, row, col, num):
    # Check if the number is not present in the same row
    if num in board[row]:
        print(f"Number {num} already present in row {row}")
        return False
    
    # Check if the number is not present in the same column
    if num in [board[i][col] for i in range(4)]:
        print(f"Number {num} already present in column {col}")
        return False
    
    # Check if the number is not present in the same 2x2 subgrid
    start_row, start_col = 2 * (row // 2), 2 * (col // 2)
    for i in range(start_row, start_row + 2):
        for j in range(start_col, start_col + 2):
            if board[i][j] == num:
                print(f"Number {num} already present in subgrid starting at ({start_row},{start_col})")
                return False
    
    return True

def is_valid_cage(board, cage):
    cage_sum, cells = cage
    total = 0
    for cell in cells:
        row, col = cell
        total += board[row][col]
    if total != cage_sum:
        print(f"Invalid cage: sum {total} does not match expected sum {cage_sum}")
        return False
    return True

def first_choice_algorithm(board, cages):
    if not cages:
        return True  # Base case: all cages are solved
    
    cage = cages[0]
    cells = cage[1]
    print(f"\n---[print] cages[0]: {cages[0]}")
    print(f"---[print] cage[1]: {cage[1]}")
    print(f"---[print] cage[1:]: {cage[1:]}\n")

    for cage in cages:
        print(f"\n---[print] for cage: {cage}")

        cageSum, cellsS = cage
        print(f"---[print] for cageSum: {cageSum}")
        print(f"---[print] for cellsS: {cellsS}")



    for cell in cells:
        row, col = cell
        print(f"\n---[print] cell: {cell}")
        print(f"---[print] row: {row}")
        print(f"---[print] col: {col}")
        print(f"---[print] board[row][col]: {board[row][col]}\n")
        if board[row][col] == 1:
            print(f"\n---[print] inside if - board[row][col]: {board[row][col]}")
            for num in range(1, 5):  # Try all numbers from 1 to 4
                print(f"Trying number {num} at cell ({row},{col})")
                if is_valid_move(board, row, col, num):
                    print(f"Number {num} is valid at cell ({row},{col})")
                    board[row][col] = num
                    if is_valid_cage(board, cage):
                        print("Valid cage")
                        if first_choice_algorithm(board, cages[1:]):
                            return True
                    print(f"Number {num} at cell ({row},{col}) is invalid for cage {cage}. Backtracking...")
                    board[row][col] = 0  # Backtrack
    return False  # No solution found

def get_cage_input(board):
    available_coordinates = [(i, j) for i in range(4) for j in range(4) if board[i][j] == 0]
    while True:
        print("Available coordinates:", available_coordinates)
        cage_input = input("Enter cage cells (row,col) separated by space (e.g., 1,1 1,2 2,1 2,2): ")
        cells = [tuple(map(int, cell.split(','))) for cell in cage_input.split()]
        if len(cells) != 4:
            print("Invalid input. Please enter exactly 4 cells.")
            continue
        valid_cells = True
        print(f"---[print] cells: {cells}\n")
        for cell in cells:
            if cell not in available_coordinates:
                print("Invalid cell coordinates or cell already assigned to another cage. Please choose from available coordinates.")
                valid_cells = False
                break
        if valid_cells:
            return cells

def get_cage_sum():
    while True:
        cage_sum = input("Enter the sum for this cage: ")
        if not cage_sum.isdigit():
            print("Invalid input. Sum must be a positive integer.")
        else:
            return int(cage_sum)

def print_boxes_layout(board):
    print("Boxes Layout:")
    for i in range(4):
        for j in range(4):
            print("+-", end="")
        print("+")
        for j in range(4):
            if board[i][j] == 0:
                print("| ", end="")
            else:
                print("|X", end="")
        print("|")

def main():
    board = generate_board()
    print("Welcome to 4x4 Killer Sudoku!")
    print("Please enter the cages:")
    print(f"\n---[print] board: {board}\n\n")
    print_boxes_layout(board)
    cages = []
    while len(cages) < 4:
        print(f"\nCage {len(cages) + 1}:")
        cells = get_cage_input(board)
        cage_sum = get_cage_sum()
        cages.append((cage_sum, cells))
        for cell in cells:
            row, col = cell
            board[row][col] = 1  # Mark cell as part of a cage
        print("Updated board:")
        # print_board(board)
        print_boxes_layout(board)
    
    print(f"\n---[print] board: {board}")
    print(f"---[print] cages: {cages}\n")
    success = first_choice_algorithm(board, cages)
    if success:
        print("\nSolution found:")
        print_board(board)
    else:
        print("\nNo solution found.")

if __name__ == "__main__":
    main()